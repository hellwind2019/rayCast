/* autogenerated by Processing revision 1293 on 2024-07-21 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.awt.Robot;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class rayCast extends PApplet {


Robot robot;
float currentRotationX = 0;
float mouseDist = 0;
float sens = 30;
final int SCREEN_HEIGHT = 600;
final int SCREEN_WIDTH = 900;
float MINMAP_SCALE = 30;
int bufferSize = width * height;
Player player = new Player(new PVector(3.5f, 3.5f));
Level level;
Game game;
PImage imageData = createImage(SCREEN_WIDTH, SCREEN_HEIGHT, RGB);
int[] buffer = new int[SCREEN_HEIGHT * SCREEN_WIDTH];
int lastTime = 0;
int delta = 0;
int halfWidth, halfHeight;
boolean threadFlag = true;
PImage wall;
public void settings() {
    size(SCREEN_WIDTH, SCREEN_HEIGHT);
}
public void setup() {
    wall = loadImage("assets/wall1.png");
    level = new Level(sceneArray, wall);
    game = new Game(player, level.scene);
    halfHeight =(int)(displayHeight*0.5f);
    halfWidth =(int)(displayWidth *0.5f);
   surface.setLocation((displayWidth / 2) - (width / 2),(displayHeight / 2) - (height / 2));
  frameRate(90);
  println(player.getFOVangle());
  try {
      robot = new Robot();
    }
  catch(Throwable e) {
}
   robot.mouseMove(displayWidth / 2, displayHeight / 2);
}
public void draw() {
    delta = millis() - lastTime;
    background(18, 18, 18);
  
    renderBuffer();
    scale(MINMAP_SCALE);
    game.drawGrid();
    game.drawPlayer();
    game.fovRaysFishEyeCorr(true);
    scale(1/MINMAP_SCALE);

    game.handlePlayerMovement();



    scale(4);
    drawFPS();

    lastTime = millis();    
}

public void mouseMoved() { 
    if(!(mouseX >= displayWidth/2 + width/2)){
        mouseDist = mouseX - width / 2 + 9;
        currentRotationX += mouseDist / sens;
        player.rotateToAngle(mouseDist / sens);
    }
  robot.mouseMove(halfWidth, halfHeight);
}
public void keyPressed() {
    game.handlePressedKeys(key);
}
public void keyReleased() {
    game.handleReleasedKeys(key); 
}
public void renderBuffer() {
    imageData.loadPixels();
    for (int i = 0; i < imageData.pixels.length; i++) {
        imageData.pixels[i] = buffer[i];
}
    imageData.updatePixels();
    image(imageData, 0, 0);
    cleanBuffer();
}
public void cleanBuffer() {
    buffer = new int[SCREEN_WIDTH * SCREEN_HEIGHT];
}
public int RAYS_FACTOR = 1;  
public class Game {
  Player player;
  int[][] scene;
  Keys keys;
  public Game(Player p, int[][] s) {
    player = p;
    scene = s;
    keys = new Keys();
  }
  public void handlePlayerMovement() {
    player.move(keys);
  }
  public void handlePressedKeys(char key) {
    if (key == 'w' || key == 'W'|| key == 'ц') keys.up.active    = true;
    if (key == 's' || key == 'S'|| key == 'і') keys.down.active  = true;
    if (key == 'a' || key == 'A'|| key == 'ф') keys.left.active  = true;
    if (key == 'd' || key == 'D'|| key == 'в') keys.right.active = true;
  }
  public void handleReleasedKeys(char key) {
    if (key == 'w' || key == 'W'|| key == 'ц') keys.up.active    = false;
    if (key == 's' || key == 'S'|| key == 'і') keys.down.active  = false;
    if (key == 'a' || key == 'A'|| key == 'ф') keys.left.active  = false;
    if (key == 'd' || key == 'D'|| key == 'в') keys.right.active = false;
  }

   public void fovRaysFishEyeCorr(boolean isVisible) {
    int RAYS_COUNT =300; //width/RAYS_FACTOR;
    //TODO: Make a way to correct resolution, RAYS_FACTOR is a bad way, have to use like fractional part 
    colorMode(HSB);
    for (int i = 0; i < RAYS_COUNT; i++) {
      float t = i/(float)RAYS_COUNT;
      t=0.5f;
      PVector planePoint = PVector.lerp(player.camL, player.camR, t);
      PVector dirPoint = PVector.lerp(player.pos, planePoint, 0.1f);
      Ray ray = new Ray();
      ray.visible = isVisible;
      ray.cast(player.pos, dirPoint);
      float brScale = 1;
      if (ray.side == 1) brScale = 1;
      if (ray.side == 0) brScale = 0.5f;
      float brightness = map(ray.length, height/2, 0, 0, 1);
      int col =  setBrightness(getColor(ray.rayColor), brightness*brScale);

      
      drawVerticalLine(i*RAYS_FACTOR, ray.length,col );
      drawTexturedLine(i*RAYS_FACTOR, ray );
    }
   colorMode(RGB);
  }
 
  public void drawGrid() {
     noStroke();
    
    fill(50, 50, 50);
    rect(0,0, level.width, level.height);
    
    strokeWeight(0.05f);
    stroke(0,0,0);

    for (int i = 0; i <= level.width; i++) {
        line(i, 0, i, level.height);
    }
    for (int i = 0; i <= level.height; i++) {
        line(0, i, level.width,i);
    }
    for (int i = 0; i < level.width; ++i) {
        for (int j = 0; j < level.height; ++j) {
        if(level.scene[j][i] != 0){
            int wallColor = getColor(level.scene[j][i]);
            fill(wallColor);
            rect(i, j, 1, 1);

        }
    }
    }
  }
  public void drawPlayer() {
    fill(200, 50, 50);
    circle(player.pos.x, player.pos.y, 0.3f);
    stroke(50, 30, 180);
    line(player.camL, player.camR);
    stroke(180, 30, 30);
    line(player.pos, player.camL);
    line(player.pos, player.camR);
  }
}
public void drawTexturedLine(int x, Ray ray){
  float wallDist = ray.length;
  int lineHeight = (int)(height / wallDist);
  int drawStart = -lineHeight / 2 + height / 2;
  if (drawStart < 0) drawStart = 0;
  int drawEnd = lineHeight / 2 + height / 2;
  if (drawEnd >= height) drawEnd = height - 1;

  PImage wall = level.getWall((int)ray.hitCell.x, (int)ray.hitCell.y);
  println(ray.hitCellXY.x +" " + ray.hitCellXY.y);
  for(int y = drawStart; y <=drawEnd; y++){

  }

}
public void drawVerticalLine(int x, float wallDist, int col) {
  int lineHeight = (int)(height / wallDist);
  int drawStart = -lineHeight / 2 + height / 2;
  if (drawStart < 0) drawStart = 0;
  int drawEnd = lineHeight / 2 + height / 2;
  if (drawEnd >= height) drawEnd = height - 1;
  
  drawLine(x, 0, drawStart, color(100, 50, 150));
  // drawLine(x, drawStart, drawEnd, col);
  drawLine(x, drawEnd, height, color(159, 25, 150));
}
public class Keys{
    Key up = new Key();
    Key down = new Key();
    Key right = new Key();
    Key left = new Key();
}
public class Key{
    boolean active = false;
}
public class Player {
  PVector pos;
  PVector dir = new PVector(0, 0.4f);
  PVector cam = new PVector(0.4f, 0);
  PVector pDir;
  PVector camL;
  PVector camR;
  float rotSpeed = PI/2 * 0.1f;
  float movSpeed = 20;

  public Player(PVector _pos) {
    pos = _pos;

    pDir = PVector.add(pos, dir);
    camL = PVector.add(pDir, cam);
    camR = PVector.sub(pDir, cam);
  }
  public float getFOVangle() {
    float dirLen = this.dir.mag();
    float camPlaneLen = this.cam.mag();
    float FOV = degrees(2*atan(camPlaneLen/dirLen));
    return  FOV;
  }
  public void rotateToAngle(float angle) {
    dir.rotate(radians(angle));
    cam.rotate(radians(angle));
  }
  public void move(Keys keys) {
    float deltaMovSpeed = movSpeed*(delta/1000.0f);
    if (keys.up.active) {
      pos.x += dir.x * deltaMovSpeed;
      pos.y += dir.y * deltaMovSpeed;
    }
    if (keys.down.active) {
      pos.x -= dir.x * deltaMovSpeed;
      pos.y -= dir.y * deltaMovSpeed;
    }
    if(keys.left.active) { 
      PVector temp = dir.copy();
      temp.rotate(radians(-90));
      pos.x += temp.x * deltaMovSpeed;
      pos.y += temp.y * deltaMovSpeed;
    }
      if(keys.right.active) { 
      PVector temp = dir.copy();
      temp.rotate(radians(90));
      pos.x += temp.x * deltaMovSpeed;
      pos.y += temp.y * deltaMovSpeed;
    }
   
    pDir = PVector.add(pos, dir);
    camL = PVector.add(pDir, cam);
    camR = PVector.sub(pDir, cam);
  }
 }
public class Ray {
    float   length    = 99999;
    int     side      = 0;
    boolean visible   = false;
    int     rayColor  = 1; 
    PVector hitCell = new PVector();
    PVector hitCellXY = new PVector();
    public void cast(PVector p, PVector m) {
        PVector d = PVector.sub(m, p);
        PVector p1 = p.copy();
        float k;
        if (d.x != 0) k = d.y / d.x;
        else k = 99999999;
        float b = p.y - k * p.x;

        for (int i = 0; i < 40; ++i) {
            m = rayStep(m, d, b, k);
            int h = floor(m.x/level.cellSize);
            int w = floor(m.y/level.cellSize);
            if(level.outsideScene((int)p1.x, (int)p1.y)){
                p1 = m.copy();
                continue;
            }  
            if(level.outsideScene(w, h) || level.scene[w][h] != 0){
                PVector rayVector = PVector.sub(m, p); 
                PVector pDir = player.dir.copy().normalize();
                float perpWallDist = PVector.dot(rayVector, pDir); //Да как в конце концов считать расстояние
                this.length = perpWallDist;
                this.rayColor = level.scene[w][h]; 
                this.hitCell.set(w,h);
                this.hitCellXY.set(m);
                stroke(200, 10, 10);
                strokeWeight(0.2f);
                line(p.x, p.y, m.x, m.y);
                return;
            }
        }
        return;
    }
    private PVector rayStep(PVector m, PVector d, float b, float k) { //Returns a next point on the grid
        float x1 = snap(m.x, d.x);
        float y1 = snap(m.y, d.y);
        float x = (y1 - b) / k;
        
        float y = k * x1 + b;
        float distX = dist(m.x, m.y, x1, y);
        float distY = dist(m.x, m.y, x, y1);
        
        if (distX <= distY) {
            this.side = 0;
            return new PVector(x1, y);
        }
        this.side = 1;
        return new PVector(x, y1);
    }
  private float snap(float p, float d) {
        
        if (d < 0) return floor(p/level.cellSize) *level.cellSize - 0.00001f;
        if (d > 0) return ceil(p/level.cellSize) *level.cellSize + 0.00001f;
        return 0;
}
}
public class Level {
    int[][] scene;
    int cellSize = 1;
    int height;
    int width;
    PImage wall1;
    public Level(int[][] scene, PImage wall1) {
        this.scene = scene;
        this.height = scene.length;
        this.width = scene[0].length;
        this.wall1 = wall1; 
    }
    public boolean outsideScene(int h, int w){
        return h < 1 || w < 1 || h>= this.height-1 || w >= this.width-1;
    }
    public PImage getWall(int x, int y){
        if(this.scene[x][y] != 0){
            return this.wall1;
        }
        return new PImage(0,0);
    } 
}

public static  int[][] sceneArray = {
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1} ,
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1} ,
    {1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1} ,
    {1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1} ,
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1} ,
    {1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1} ,
    {1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1} ,
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1} ,
    {1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1} ,
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1} ,
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1} ,
    {1, 0, 0, 1, 0, 5, 4, 0, 0, 0, 0, 0, 0, 0, 0, 1} ,
    {1, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1} ,
    {1, 0, 1,2, 3, 4, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1} ,
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1} ,
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
};
public void print2(float a, float b){ 
 print(a);
 print('\t');
 println(b);
}
public float cellSize(int[][] scene) {
  int sh = scene.length;
  int sw = scene[0].length;
  int cs = height / sh;
  return cs;
}
public void line(PVector p1, PVector p2) {
  line(p1.x, p1.y, p2.x, p2.y);
}
public void drawFPS() {
  int fps = (int)frameRate;
  text(fps, 10, 10);
}
public void drawPixel(int x, int y, int col) {
    int offcet = ( x+ y * width);
    buffer[offcet] = col;
}
public void drawLine(int x1, int y1, int y2, int col) {
  for (int y = y1; y < y2; y++) {
      drawPixel(x1, y, col);
  }
}
public int getColor(int index){
switch ( index) {
   case 1 : return color(0xFF292625); 
   case 2 : return color(50, 180, 180);
   case 3 : return color(120, 210, 180);
   case 4 : return color(150, 120, 180); 
   case 5 : return color(200, 190, 180); 
   default :
    return color(0, 50, 50);
}
}
public int setBrightness(int col, float br)
{
    float h, s, b;
    h = hue(col);
    s = saturation(col);
    b = brightness(col);
    b *=br;
    return color(h,s,b);
}


  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "rayCast" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
